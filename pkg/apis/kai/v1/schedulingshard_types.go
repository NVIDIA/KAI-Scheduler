/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
	"strconv"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/utils/ptr"

	"github.com/NVIDIA/KAI-scheduler/pkg/apis/kai/v1/common"
	usagedbapi "github.com/NVIDIA/KAI-scheduler/pkg/scheduler/cache/usagedb/api"
)

const (
	binpackStrategy = "binpack"
	spreadStrategy  = "spread"
)

// PluginConfig allows overriding plugin settings in the scheduler configuration.
type PluginConfig struct {
	// Enabled controls whether this plugin is active. Defaults to true.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty"`

	// Priority controls the ordering of this plugin. Higher values run first.
	// Built-in plugins use priorities in the range 0-10000, spaced by 100.
	// +kubebuilder:validation:Optional
	Priority *int `json:"priority,omitempty"`

	// Arguments are key-value pairs passed to the plugin. When specified, they fully replace
	// the default arguments for the plugin.
	// +kubebuilder:validation:Optional
	Arguments map[string]string `json:"arguments,omitempty"`
}

// ActionConfig allows overriding action settings in the scheduler configuration.
type ActionConfig struct {
	// Enabled controls whether this action is active. Defaults to true.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty"`

	// Priority controls the ordering of this action. Higher values run first.
	// Built-in actions use priorities in the range 0-10000, spaced by 100.
	// +kubebuilder:validation:Optional
	Priority *int `json:"priority,omitempty"`
}

// NOTE: json tags are required.  Any new fields you add must have json tags for the fields to be serialized.

// SchedulingShardSpec defines the desired state of SchedulingShard
type SchedulingShardSpec struct {
	// Args specifies custom CLI arguments for the scheduler. These are merged with automatically generated flags.
	// Valid flags are those defined in the scheduler's code. Usage examples:
	// - To pass "--custom-flag=value": Args: {"custom-flag": "value"}
	// - To override default flags like "--leader-elect": Args: {"leader-elect": "true"}
	// Note:
	//   * Flag names must match exactly (case-sensitive)
	//   * Values are passed as strings
	//   * Only valid flags defined in the scheduler's flag set will be accepted
	//   * Duplicated flags will override the behavior of flags generated by other fields
	// +kubebuilder:validation:Optional
	Args map[string]string `json:"args,omitempty"`

	// PlacementStrategy is the placement scheduler strategy
	// +kubebuilder:validation:Optional
	PlacementStrategy *PlacementStrategy `json:"placementStrategy,omitempty"`

	// PartitionLabelValue is the value for the partition label
	// +kubebuilder:validation:Optional
	PartitionLabelValue string `json:"partitionLabelValue,omitempty"`

	// QueueDepthPerAction max number of jobs to try for action per queue
	// +kubebuilder:validation:Optional
	QueueDepthPerAction map[string]int `json:"queueDepthPerAction,omitempty"`

	// MinRuntime specifies the minimum runtime of a jobs in the shard
	// +kubebuilder:validation:Optional
	MinRuntime *MinRuntime `json:"minRuntime,omitempty"`

	// KValue specifies the kValue for the proportion plugin. Default is 1.0.
	// +kubebuilder:validation:Optional
	KValue *float64 `json:"kValue,omitempty"`

	// UsageDBConfig defines configuration for the usage db client
	// +kubebuilder:validation:Optional
	UsageDBConfig *usagedbapi.UsageDBConfig `yaml:"usageDBConfig,omitempty" json:"usageDBConfig,omitempty"`

	// Plugins allows overriding plugin configuration. Keys are plugin names.
	// Built-in plugins can be disabled, reordered, or have their arguments changed.
	// New plugins can be added by specifying a name not in the default set.
	// Default plugins and their priorities (higher runs first):
	// predicates=1900, proportion=1800, priority=1700, nodeavailability=1600,
	// resourcetype=1500, podaffinity=1400, elastic=1300, kubeflow=1200,
	// ray=1100, subgrouporder=1000, taskorder=900, nominatednode=800,
	// dynamicresources=700, minruntime=600, topology=500, snapshot=400,
	// gpupack/gpuspread=300, nodeplacement=200, gpusharingorder=100.
	// +kubebuilder:validation:Optional
	Plugins map[string]PluginConfig `json:"plugins,omitempty"`

	// Actions allows overriding action configuration. Keys are action names.
	// Built-in actions can be disabled or reordered.
	// New actions can be added by specifying a name not in the default set.
	// Default actions and their priorities (higher runs first):
	// allocate=500, consolidation=400, reclaim=300, preempt=200, stalegangeviction=100.
	// +kubebuilder:validation:Optional
	Actions map[string]ActionConfig `json:"actions,omitempty"`
}

func (s *SchedulingShardSpec) SetDefaultsWhereNeeded() {
	s.PlacementStrategy = common.SetDefault(s.PlacementStrategy, &PlacementStrategy{})
	s.PlacementStrategy.SetDefaultWhereNeeded()

	s.setDefaultPlugins()
	s.setDefaultActions()
}

// Default priorities preserve the current hardcoded ordering.
// Higher priority = runs first. Spaced by 100.
var defaultPluginPriorities = map[string]int{
	"predicates":       1900,
	"proportion":       1800,
	"priority":         1700,
	"nodeavailability": 1600,
	"resourcetype":     1500,
	"podaffinity":      1400,
	"elastic":          1300,
	"kubeflow":         1200,
	"ray":              1100,
	"subgrouporder":    1000,
	"taskorder":        900,
	"nominatednode":    800,
	"dynamicresources": 700,
	"minruntime":       600,
	"topology":         500,
	"snapshot":         400,
	"gpupack":          300,
	"gpuspread":        300,
	"nodeplacement":    200,
	"gpusharingorder":  100,
}

var defaultActionPriorities = map[string]int{
	"allocate":          500,
	"consolidation":     400,
	"reclaim":           300,
	"preempt":           200,
	"stalegangeviction": 100,
}

func (s *SchedulingShardSpec) setDefaultPlugins() {
	defaults := make(map[string]PluginConfig)

	for pName, pPriority := range defaultPluginPriorities {
		defaults[pName] = PluginConfig{
			Enabled:   ptr.To(true),
			Priority:  ptr.To(pPriority),
			Arguments: make(map[string]string),
		}
	}

	isGpuBinpackStrategy := *s.PlacementStrategy.GPU == binpackStrategy
	updateMap(defaults, "gpusharingorder", func(o *PluginConfig) { o.Enabled = ptr.To(isGpuBinpackStrategy) })
	updateMap(defaults, "gpupack", func(o *PluginConfig) { o.Enabled = ptr.To(isGpuBinpackStrategy) })
	updateMap(defaults, "gpuspread", func(o *PluginConfig) { o.Enabled = ptr.To(!isGpuBinpackStrategy) })

	if s.KValue != nil {
		defaults["proportion"].Arguments["kValue"] = strconv.FormatFloat(*s.KValue, 'f', -1, 64)
	}

	if s.MinRuntime != nil {
		if s.MinRuntime.PreemptMinRuntime != nil {
			defaults["minruntime"].Arguments["defaultPreemptMinRuntime"] = *s.MinRuntime.PreemptMinRuntime
		}
		if s.MinRuntime.ReclaimMinRuntime != nil {
			defaults["minruntime"].Arguments["defaultReclaimMinRuntime"] = *s.MinRuntime.ReclaimMinRuntime
		}
	}

	defaults["nodeplacement"].Arguments["gpu"] = *s.PlacementStrategy.GPU
	defaults["nodeplacement"].Arguments["cpu"] = *s.PlacementStrategy.CPU

	// Merge user overrides
	for name, override := range s.Plugins {
		existing, found := defaults[name]
		if !found {
			existing = PluginConfig{Enabled: ptr.To(true), Priority: ptr.To(0)}
		}
		if override.Enabled != nil {
			existing.Enabled = override.Enabled
		}
		if override.Priority != nil {
			existing.Priority = override.Priority
		}
		if override.Arguments != nil {
			existing.Arguments = override.Arguments
		}
		defaults[name] = existing
	}

	s.Plugins = defaults
}

func (s *SchedulingShardSpec) setDefaultActions() {
	defaults := make(map[string]ActionConfig)

	for aName, aPriority := range defaultActionPriorities {
		defaults[aName] = ActionConfig{
			Enabled:  ptr.To(true),
			Priority: ptr.To(aPriority),
		}
	}

	isConsolidationEnabled := *s.PlacementStrategy.GPU != spreadStrategy && *s.PlacementStrategy.CPU != spreadStrategy
	updateMap(defaults, "consolidation", func(o *ActionConfig) { o.Enabled = ptr.To(isConsolidationEnabled) })

	// Merge user overrides
	for name, override := range s.Actions {
		existing, found := defaults[name]
		if !found {
			// New action: default priority 0, enabled true
			existing = ActionConfig{
				Enabled:  ptr.To(true),
				Priority: ptr.To(0),
			}
		}
		if override.Enabled != nil {
			existing.Enabled = override.Enabled
		}
		if override.Priority != nil {
			existing.Priority = override.Priority
		}
		defaults[name] = existing
	}

	s.Actions = defaults
}

type MinRuntime struct {
	// PreemptMinRuntime specifies the minimum runtime of a job in queue before it can be preempted
	// +kubebuilder:validation:Optional
	PreemptMinRuntime *string `json:"preemptMinRuntime,omitempty"`

	// ReclaimMinRuntime specifies the minimum runtime of a job in queue before it can be reclaimed
	// +kubebuilder:validation:Optional
	ReclaimMinRuntime *string `json:"reclaimMinRuntime,omitempty"`
}

// PlacementStrategy defines the scheduling strategy of NodePool
type PlacementStrategy struct {
	// GPU scheduling strategy (binpack/spread)
	// +kubebuilder:validation:Optional
	GPU *string `json:"gpu,omitempty"`

	// CPU scheduling strategy (binpack/spread)
	// +kubebuilder:validation:Optional
	CPU *string `json:"cpu,omitempty"`
}

func (p *PlacementStrategy) SetDefaultWhereNeeded() {
	p.GPU = common.SetDefault(p.GPU, ptr.To(binpackStrategy))
	p.CPU = common.SetDefault(p.CPU, ptr.To(binpackStrategy))
}

// SchedulingShardStatus defines the observed state of SchedulingShard
type SchedulingShardStatus struct {
	Conditions []metav1.Condition `json:"conditions,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster

// SchedulingShard is the Schema for the schedulingshards API
type SchedulingShard struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   SchedulingShardSpec   `json:"spec,omitempty"`
	Status SchedulingShardStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// SchedulingShardList contains a list of SchedulingShard
type SchedulingShardList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SchedulingShard `json:"items"`
}

func init() {
	SchemeBuilder.Register(&SchedulingShard{}, &SchedulingShardList{})
}
